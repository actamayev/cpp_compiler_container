name: Docker Build Check

on: push

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      # - name: Checkout code
      #   uses: actions/checkout@v4

      # - name: Configure AWS Credentials
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #     aws-region: us-east-1

      - name: Check shell script syntax
        run: |
          bash -n entrypoint.sh

      - name: Hadolint - Dockerfile linter
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile
          failure-threshold: warning
          format: tty
          no-fail: false

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          load: true
          tags: firmware-compiler:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # - name: Test staging and production environments
      #   run: |
      #         # Create persistent volumes for tests
      #         docker volume create firmware-compiler-workspace
      #         docker volume create pio-cache

      #         # Test server for each environment
      #         for env in "staging" "production"; do
      #           echo "Testing $env environment server..."

      #           # Start the container in detached mode
      #           CONTAINER_ID=$(docker run -d \
      #             -p 3001:3001 \
      #             -v firmware-compiler-workspace:/workspace \
      #             -v pio-cache:/root/.platformio \
      #             -e ENVIRONMENT=$env \
      #             -e SERVER_PORT=3001 \
      #             -e GITHUB_APP_ID=${{ secrets.GH_APP_ID }} \
      #             -e GITHUB_APP_PRIVATE_KEY="${{ secrets.GH_APP_PRIVATE_KEY }}" \
      #             -e GITHUB_INSTALLATION_ID=${{ secrets.GH_INSTALLATION_ID }} \
      #             firmware-compiler:test)

      #           # Debug: Print environment variables inside container
      #           docker exec $CONTAINER_ID env

      #           # Debug: Check if app can see the variables
      #           docker exec $CONTAINER_ID node -e "console.log('GITHUB_APP_ID:', process.env.GITHUB_APP_ID)"
      #           docker exec $CONTAINER_ID node -e "console.log('GITHUB_INSTALLATION_ID:', process.env.GITHUB_INSTALLATION_ID)"

      #           # Wait for server to start
      #           echo "Waiting for server to start..."
      #           sleep 10

      #           # Test health endpoint first
      #           echo "Testing health endpoint..."
      #           health_response=$(curl -s http://localhost:3001/health)
      #           echo "Health check response: $health_response"

      #           # Test compile endpoint
      #           echo "Testing compile endpoint..."
      #           compile_response=$(curl -X POST \
      #             -H "Content-Type: application/json" \
      #             -d '{"userCode":"delay(1000);","pipUUID":"test123"}' \
      #             http://localhost:3001/compile)
      #           echo "Compile response: $compile_response"

      #           # Check if compile response indicates success
      #           if echo "$compile_response" | grep -q '"success":false'; then
      #             echo "Compilation failed in $env environment"
      #             docker logs $CONTAINER_ID
      #             docker stop $CONTAINER_ID
      #             exit 1
      #           fi
                
      #           # Stop the container
      #           docker stop $CONTAINER_ID
      #         done
  
      - name: Cleanup
        if: always()
        run: |
            docker system prune -f
            docker volume rm firmware-compiler-workspace pio-cache
